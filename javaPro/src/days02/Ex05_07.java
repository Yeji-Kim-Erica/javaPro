package days02;

public class Ex05_07 {
	public static void main(String[] args) {
		
		/*
		 * [진법변환]
		 * 10진법 : 0 1 2 3 4 5 6 7 8 9
		 * 2진법 : 0 1
		 * 
		 * 컴퓨터는 10진수를 2진수로 변환해서 저장함.
		 * 	예시) 10이라는 10진수를 2진수로 나타내보자.
		 * 	10을 2로 계속 나눈다.
		 * 	10 나누기 2 -> 몫: 5, 나머지: 0
		 * 	5 나누기 2 -> 몫: 2, 나머지: 1
		 * 	2 나누기 2 -> 몫: 1, 나머지: 0
		 * 	1 나누기 2 -> 몫: 0, 나머지: 1
		 * 나머지를 역순으로 1010 => 10을 2진수로 나타낸 것임.
		 * 
		 * 10 -> byte i = 10;
		 * 		  [0][0][0][0][1][0][1][0]
		 * 		 short s = 10;
		 * 		  [0][0][0][0][0][0][0][0] [0][0][0][0][1][0][1][0]
		 * 
		 * 10을 8진수로 : 012
		 * 10을 16진수로 : 0xa
		 */
		 
		// 음수가 저장되는 방법은 뭘까?
		// [음수 표현 방법]
		// 1. 부호와 절대치 (ex: -10)
		// 2. 1의 보수법 (ex: )
		// 3. (현재) 2의 보수법
		
		byte b = -10;
		
		// 1번 방법
		// |-10|
		// 10
		// 0000 1010
		// [부호비트][][][][][][][]
		// 단점임: 0이 두가지로 표현됨. 낭비.
		// [1][0][0][0] [0][0][0][0] -0
		// [0][0][0][0] [0][0][0][0] +0
		// 부호와 절대치 말고 1의 보수법으로 나타내자~ (2번의 등장)
		
		// 2번 방법
		// |-10|
		// 10
		// 0000 1010
		// 1111 0101 -> 보수 작업을 하면 이렇게 됨. 0은 1로, 1은 0으로.
		
		// 3번 방법 (2의 보수법)
		// 	1) 절대치
		// |-10|
		// 10
		// 0000 1010 (2진법으로 작성)
		// 2) 1의 보수법
		// 1111 0101
		// 3) 2의 보수법 : +를 하나 하자!
		// 1111 0101 + 0000 0001 => 1111 0110
		
		// [문제] 어떤 음수가 2의 보수법 저장 : 1010 1010
		// 음수 얼마일까요?
		// 2의 보수법 리버스 : 1010 1001
		// 1의 보수법 리버스 : 0101 0110
		// 2진법을 다시 10진법으로 계산 : 2+4+16+64 = 86
		// 정답은 -86!
		
	}
}
