package days03;

/**
 * @author yejikim
 * @date 2025. 2. 5. - 오전 11:22:31
 * @subject float, double 자료형이 저장되는 방법
 * @content
 */
public class Ex04 {
	public static void main(String[] args) {
		// [예] 9.123456 실수 -> 2진수 실수 변환 -> float(4)/double(8)
		//	   1001.00011111100110101101101111100110101101101111001101011011011110011010110110111100110101101101...
		// 부동소수점 표기법: 소수점을 항상 1부터 시작되도록 하는 표기법
		//		ㄴ 가수(M): 부동소수점 표기법으로 만든 가짜 수
		//	1.00100011111100110101101101111100110101101101111001101011011011110011010110110111100110101101101...
		//	ㄴ 가수임.
		// 곱하기 2^3 (=8) 하면 1001. ~과 같은 값이 됨.
		// 	ㄴ 여기서 3은 지수임. 지수는 E로 표기.
		
		// int(4) 10
		// [][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][1][0][1][0]
		
		// float(4) 단정도 정밀도
		//       [8비트로 E를 표현   ][나머지 23비트가 M을 표현                          ]
		// [s(1)][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][][][][]
		// 첫번째 비트에는 부호가 들어감
		
		// double(8) 배정도 정밀도 (단정도보다 더 정밀)
		// 		 [11비트로 E 표현         ][52비트로 M 표현                                                                              ]
		// [s(1)][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][][][][] [][][][][][][][]
		
		// 단정도와 배정도를 비교해보면 가수(M)을 표현할 수 있는 비트가 더 많은 double은 정보의 손실이 덜함.
		
		// 오차가 없는 실수를 사용하려면?
		// BigDecimal 클래스를 사용하면 됨.
		
		char c = '\u0041'; // 유니코드 2바이트
		// \u0041은
		// [][][][][][][][][][][][][][][][]
		// ________________ 0 1 0 0 0 0 0 1 ?
		// 선생님께 이 부분 여쭤보기
		
		/*
		 * 10을 2진수로 하면 0000 1010
		 * 2진수를 3비트씩 끊어 읽으면 8진수를 알 수 있음
		 * 00 001 010 -> 0 1 2
		 * 16진수는 4비트씩 (지수만큼 끊어 읽기)
		 * 0000 1010 -> 0 a
		 * 
		 */
		
		// 이 페이지는 선생님 페이지 참고할 것.
	}
}
